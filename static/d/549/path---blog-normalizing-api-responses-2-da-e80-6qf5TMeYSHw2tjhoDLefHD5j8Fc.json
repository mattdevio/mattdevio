{"data":{"markdownRemark":{"html":"<p><a href=\"https://expressjs.com\">Express.js</a> has been my goto framework for building an API in node. One of the problems I commonly run into is that with enough freedom, each api response tends to take on it's own shape. This creates a weird code smell when each remote call has to think about how to consume each response.</p>\n<blockquote>\n<p>Note: All examples are using <a href=\"https://www.npmjs.com/package/express\">express v4</a> and <a href=\"https://www.npmjs.com/package/body-parser\">body-parser</a>.</p>\n</blockquote>\n<pre><code class=\"language-js\">const todos = [{ ... }, { ... }]; // an array of todos\n\nrouter.get('/todos', function(req, res, next){\n    res.status(200);\n    res.json({\n        msg: 'So many things to do',\n        todos: todos,\n    });\n});\n\nrouter.post('/todos', function(req, res, next){\n    const todo = {\n        title: req.body.title,\n        description: req.body.description,\n        completed: false,\n        id: uuid(), // generate a random id,\n    };\n    try {\n        todos.push(todo); // imagine this might fail, todo is a remote db :)\n    } catch (e) {\n        return next(e);\n    }\n    res.status(201);\n    res.json({\n        message: 'Todo created',\n        data: todo,\n    });\n});\n</code></pre>\n<p>Above you can see that each endpoint has it's own structure for the response given a very similar anatomy. Both are sending back a message and a data set, but with different keys. This problem becomes even more evident when you start throwing errors into the mix.</p>\n<h2>Normalizing the API response</h2>\n<p>We can fix this problem by creating a function that returns an object. For simplicity, this object will have 4 key value pairs</p>\n<ul>\n<li>data - The main data, defaults to an object be can be any type</li>\n<li>status - Was the request successful, 1 is OK, 0 is BAD</li>\n<li>errors - An array of errors generated in processing</li>\n<li>message - A user friendly message of what happened</li>\n</ul>\n<pre><code class=\"language-js\">function apiResponse(data = {}, status = 1, errors = [], message = '') {\n    return {\n        data,\n        status,\n        errors,\n        message,\n    };\n}\n</code></pre>\n<p>Thats a good start, but your fellow developer has to think about which order the parameters are in. Lets fix that by accepting a object as a parameter and destructuring the keys we need out of it.</p>\n<pre><code class=\"language-js\">function apiResponse({ data = {}, status = 1, errors = [], message = '' }) {\n    return {\n        data,\n        status,\n        errors,\n        message,\n    };\n}\n</code></pre>\n<p>While that solution works, it doesn't protect us from mistakes. After initialization, the integrity of the object structure is at risk. Lets turn apiResponse into a class so we can gain more control.</p>\n<pre><code class=\"language-js\">class ApiResponse {\n    constructor({ data = {}, status = 1, errors = [], message = '' }) {\n        this._data = data;\n        this._status = status;\n        this._errors = errors;\n        this._message = message;\n    }\n}\n</code></pre>\n<p>Under the hood, <code>res.json()</code> will call <code>JSON.stringify()</code> on the payload to encode it. One of the cool side affects of <code>stringify</code> is that if an object has a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#toJSON()_behavior\">toJSON</a> property whose value is a function, that function will be called to define how the object is serialized. This means we can pick which keys show up in the JSON string.</p>\n<pre><code class=\"language-js\">class ApiResponse {\n    constructor({ data = {}, status = 1, errors = [], message = '' }) {\n        this._data = data;\n        this._status = status;\n        this._errors = errors;\n        this._message = message;\n    }\n    toJSON() {\n        return {\n            data: this._data,\n            status: this._status,\n            errors: this._errors,\n            message: this._message,\n        };\n    }\n}\n</code></pre>\n<p>Unfortunately, javascript classes don't have private keys. The closest thing we have is <code>Symbols</code>. Lets use those to make our keys \"private\".</p>\n<pre><code class=\"language-js\">const apiResponse = (payload = {}) => {\n\n    const DataSymbol = Symbol('data');\n    const StatusSymbol = Symbol('status');\n    const ErrorsSymbol = Symbol('errors');\n    const MessageSymbol = Symbol('message');\n\n    class ApiResponse {\n        constructor({ data = {}, status = 1, errors = [], message = '' }) {\n            this[DataSymbol] = data;\n            this[StatusSymbol] = status;\n            this[ErrorsSymbol] = errors;\n            this[MessageSymbol] = message;\n        }\n        toJSON() {\n            return {\n                data: this[DataSymbol],\n                status: this[StatusSymbol],\n                errors: this[ErrorsSymbol],\n                message: this[MessageSymbol],\n            }\n        }\n    }\n\n    return new ApiResponse(payload);\n\n}\n</code></pre>\n<p>Javascript also doesn't have types, but we do have <code>getters</code> and <code>setters</code>. We can use those to do type checking on assignment. This is our final evolution of the code.</p>\n<pre><code class=\"language-js\">const apiResponse = (payload = {}) => {\n\n    const DataSymbol = Symbol('data');\n    const StatusSymbol = Symbol('status');\n    const ErrorsSymbol = Symbol('errors');\n    const MessageSymbol = Symbol('message');\n\n    class ApiResponse {\n        constructor({ data = {}, status = 1, errors = [], message = '' }) {\n            this.data = data;\n            this.status = status;\n            this.errors = errors;\n            this.message = message;\n        }\n\n        get data() {\n          return this[DataSymbol];\n        }\n\n        set data(data) {\n          if (typeof data === 'undefined')\n              throw new Error('Data must be defined');\n          this[DataSymbol] = data;\n        }\n\n        get status() {\n          return this[StatusSymbol];\n        }\n\n        set status(status) {\n          if (isNaN(status) || (status !== 0 &#x26;&#x26; status !== 1))\n            throw new Error('Status must be a number, 1 is OK, 0 is BAD');\n          this[StatusSymbol] = status;\n        }\n\n        get errors() {\n          return this[ErrorsSymbol];\n        }\n\n        set errors(errors) {\n          if (!Array.isArray(errors))\n            throw new Error('Errors must be an array');\n          this[ErrorsSymbol] = errors;\n        }\n\n        get message() {\n          return this[MessageSymbol];\n        }\n\n        set message(message) {\n          if (typeof message !== 'string')\n            throw new Error('Message must be a string');\n          this[MessageSymbol] = message;\n        }\n\n        toJSON() {\n            return {\n                data: this.data,\n                status: this.status,\n                errors: this.errors.map(e => e.stack ? e.stack : e),\n                message: this.message,\n            }\n        }\n    }\n\n    return new ApiResponse(payload);\n\n}\n</code></pre>\n<p>The getters and setters also give us the ability to safely mutate a response object after initialization. Now comes the fun part, using our new <code>apiResponse</code> function ðŸŽ‰!</p>\n<pre><code class=\"language-js\">const todos = [{ ... }, { ... }]; // an array of todos\n\nrouter.get('/todos', function(req, res, next){\n    res.status(200);\n    res.json(apiResponse({\n        data: todos,\n        message: 'You have a lot todo!',\n    }));\n});\n</code></pre>\n<p><strong>Expected Response from GET /todos</strong></p>\n<pre><code class=\"language-json\">{\n   \"data\": [{ ... }, { ... }],\n   \"message\": \"You have a lot todo!\",\n   \"errors\": [],\n   \"status\": 1,\n}\n</code></pre>\n<p>That is all for now. This is my first post and would love to hear your feedback. Hopefully this is helpful to someone. Happy Coding!</p>","frontmatter":{"date":"March 28, 2019","path":"/blog/normalizing+api+responses","title":"Normalizing API Responses"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}